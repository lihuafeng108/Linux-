
一、编译链接库文件时，通过选项增加头文件和库文件搜寻路径，指定加载库文件
===

1、编译选项-I -L -l
---
    Linux 下的大多默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下，但并不是所有的情况都是这样。  
    正因如此，GCC在编译时必须有自己的办法来查找所需要的头文件和库文件。GCC采用搜索目录的办法来查找所需要的文件，  
    -I选项可以向GCC的头文件搜索路径中添加新的目录。例如，如果在/home/justin/include/ 目录下有编译时所需要的头文件，  
    为了让GCC能够顺利地找到它们，就可以使用 -I 选项：  
    gcc foo.c -I /home/justin/include -o foo  
    
    同样，如果使用了不在标准位置的库文件，那么可以通过-L选项向GCC的库文件搜索路径中添加新的目录。例如，如果在   
    /home/xiaowp/lib/目录下有链接时所需要的库文件 libfoo.so ，为了让 GCC 能够顺利地找到它，可以使用下面的命令：  
    gcc foo.c -L /home/justin/lib -lfoo -o foo  
    
    得好好解释一下的是-l选项，它指示GCC去连接库文件 libfoo.so 。Linux下的库文件在命名时有一个约定，那就是应该以lib  
    三个字母开头，由于所有的库文件都遵循了同样的规范，因此在用-l 选项指定链接的库文件名时可以省去lib 三个字母，也就是  
    说GCC 在对-lfoo 进行处理时，会自动去链接名为libfoo.so。  
    Linux下的库文件分为两大类分别是动态链接库（通常以.so 结尾）和静态链接库（通常以.a 结尾），两者的差别仅在程序执行时  
    所需的代码是在运行时动态加载的，还是在编译时静态加载的 。默认情况下，GCC在链接时优先使用动态链接库，只有当动态链接库  
    不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static 选项，强制使用静态链接库。例如，如果在  
    home/justin/lib/ 目录下有链接时所需要的库文 件libfoo.so 和libfoo.a ，为了让GCC 在链接时只用到静态链接库，可以  
    使用下面的命令  
    gcc foo.c -L /home/justin/lib -static -lfoo -o foo  
    
2、共享库两种加载方式简述
---
    动态库技术通常能减少程序的大小，节省空间，提高效率，具有很高的灵活性，对于升级软件版本也更加容易。与静态库不同，动态库  
    里面的函数不是执行程序本身 的一部分，而是在程序执行时按需载入，其执行代码可以同时在多个程序中共享。由于在编译过程中无法  
    知道动态库函数的地址，所以需要在运行期间查找，这对程序的性能会有影响.
    
    对于共享库来讲，它只包括2个段：只读的代码段和可修改的数据段。堆和栈段，只有进程才有。如果你在共享库的函数里，分配了一块  
    内存，这段内存将被算在调用该函数的进程的堆中。代码段由于其内容是对每 个进程都是一样的，所以它在系统中是唯一的，系统只为其  
    分配一块内存，多个进程之间共享。数据段由于其内容对每个进程是不一样的，所以在链接到进程空间 后，系统会为每个进程创建相应的  
    数据段。也就是说如果一个共享库被N个进程链接，当这N个进程同时运行时，同时共享一个代码段，每个进程拥有一个数据段，系统中共  
    有N个数据段。PIC即position independent code，使.so文件的代码段变为真正意义上的共享。如果编译时不加-fPIC,则加载.so文件  
    的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个.so文件代码段的进程在内核里都会生  
    成这个.so文件代码段的copy。

    加载方式：
    1）静态加载（编译程序选择默认的方式）
    在程序编译的时候加上“-l”选项，指定其所依赖的动态库，这个库的名字将记录在ELF文件的.dynamic节。在程序运行时，loader会预先  
    将程序所依赖的所有动态库都加载在进程空间中。  
    优点：动态库的接口调用简单，可以直接调用。  
    缺点：动态库的生存周期等于进程的生存周期，其加载时机不灵活。  
    
    2）动态加载（我们地区应用动态库采用这种方式）
    在程序中编码来指定加载动态库的时机，经常使用的函数dlopen和dlclose。  
    优点：动态库加载的时机非常灵活，可以非常细致的定义动态库的生存周期。  
    缺点：动态库的接口调用起来比较麻烦，同时还要关注动态库的生存周期。  

-------

二、linux下程序寻找动态库路径（按优先级排列）
===

1.编译生成时，指定的搜索路径。
---
    在makefile中，一般使用”-Wl -rpath”来指明程序运行时到哪个路径去找库。当指定多个动态库搜索路径时，路径之间用冒号隔开，不能有空格。

2.环境变量LD_LIBRARY_PATH中指定的路径。
---
    可以使用 echo LD_LIBRARY_PATH查看。一般初始时/lib和/user/lib库包含在里面。用户可以往里面添加。

3./etc/ld.so.cache中缓存的路径。
---
    /etc/ld.so.conf的第一行有一个引用命令：include ld.so.conf.d/*.conf, 所以可以通过修改/etc/ls.so.conf这个配置文件来  
    增删路径,也可以增加一个.conf文件来配置特有的动态库路径。直接将寻库路径加进来即可，保存后需要运行一下ldconfig重载一下。

4.默认的/lib/和/usr/lib。
--
    这两个路径是系统最初就添加在LD_LIBRARY_PATH中，所以将库移动到这里亦可以寻找到。
  
补充：程序运行时不会把当前目录作为默认的寻库路径，除非你在编译时指定了
--
